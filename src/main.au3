#NoTrayIcon

#Region AutoIt3Wrapper directives section
#AutoIt3Wrapper_Icon=juno_okyo.ico
#AutoIt3Wrapper_Compression=4
#AutoIt3Wrapper_UseUpx=Y
#AutoIt3Wrapper_Res_Comment=Developed by Juno_okyo
#AutoIt3Wrapper_Res_Description=Developed by Juno_okyo
#AutoIt3Wrapper_Res_Fileversion=1.0.0.0
#AutoIt3Wrapper_Res_FileVersion_AutoIncrement=Y
#AutoIt3Wrapper_Res_ProductVersion=1.0.0.0
#AutoIt3Wrapper_Res_LegalCopyright=(C) 2016 Juno_okyo. All rights reserved.
#AutoIt3Wrapper_Res_Field=CompanyName|J2TeaM
#AutoIt3Wrapper_Res_Field=Website|https://junookyo.blogspot.com/
#EndRegion AutoIt3Wrapper directives section

#Region Includes
#include <ButtonConstants.au3>
#include <ComboConstants.au3>
#include <EditConstants.au3>
#include <GUIConstantsEx.au3>
#include <GUIListBox.au3>
#include <StaticConstants.au3>
#include <TabConstants.au3>
#include <WindowsConstants.au3>
#include <Misc.au3>
#include <Array.au3>
#include <GuiListView.au3>
#include <String.au3>
#include <juno_okyo.au3>
#include <File.au3>
#include <GuiTab.au3>
#include <WinAPIProc.au3>
#include "resources.au3"
#include "i18n.au3"
#EndRegion Includes

_Singleton(@ScriptName)

#Region Options
Opt('MustDeclareVars', 1)
Opt('WinTitleMatchMode', 2)
Opt('GUICloseOnESC', 0)
Opt('GUIOnEventMode', 1)
Opt('TrayOnEventMode', 1)
Opt('TrayMenuMode', 3)
#EndRegion Options

; Script Start - Add your code below here
Global Const $TEMP_DIR = @TempDir & '\juno_okyo\'
Global Const $banner = $TEMP_DIR & 'J2TeaM.jpg'
Global Const $md5deep = $TEMP_DIR & 'md5deep.exe'
Global Const $md5txt = @ScriptDir & '\md5.txt'

; md5deep.exe = 5ad77de20e4eac2b359b4b94a8a80b81
If Not FileExists($md5txt) Or Not FileExists($md5deep) Or _MD5ForFile($md5deep) <> '5ad77de20e4eac2b359b4b94a8a80b81' Then
	Exit (1)
EndIf

Global Const $db = StringLower(_ArrayToString(FileReadToArray($md5txt)))
Global $driveNum = 0

#Region ### START Koda GUI section ###
Global $FormMain = GUICreate("Malware Scanner by Juno_okyo", 435, 451)
GUISetFont(12, 400, 0, "Segoe UI")
GUISetOnEvent($GUI_EVENT_CLOSE, "FormMainClose")
Global $Pic1 = GUICtrlCreatePic($banner, 0, 0, 434, 140)
GUICtrlSetOnEvent($Pic1, "BannerClick")
Global $Tab1 = GUICtrlCreateTab(8, 152, 417, 177)
GUICtrlSetOnEvent(-1, "TabChange")
Global $TabSheet1 = GUICtrlCreateTabItem(i18n('quick-scan'))
Global $cb_program_files = GUICtrlCreateCheckbox(i18n('program-files-dir'), 17, 216, 193, 25)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $cb_running_process = GUICtrlCreateCheckbox(i18n('running-process'), 17, 186, 233, 25)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $cb_windir = GUICtrlCreateCheckbox(i18n('win-dir'), 17, 246, 161, 25)
GUICtrlSetState(-1, $GUI_CHECKED)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Button1 = GUICtrlCreateButton(i18n('start-scan'), 17, 276, 100, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
GUICtrlSetOnEvent(-1, "BtnQuickScanClick")
GUICtrlSetCursor(-1, 0)
Global $TabSheet2 = GUICtrlCreateTabItem(i18n('scan-all'))
Global $List1 = GUICtrlCreateList("", 17, 186, 241, 90, BitOR($GUI_SS_DEFAULT_LIST, $LBS_MULTIPLESEL))
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Button2 = GUICtrlCreateButton(i18n('start-scan'), 17, 286, 100, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
GUICtrlSetOnEvent(-1, "Button2Click")
GUICtrlSetCursor(-1, 0)
Global $TabSheet3 = GUICtrlCreateTabItem(i18n('custom-scan'))
Global $Label1 = GUICtrlCreateLabel(i18n('browse-folder'), 17, 186, 105, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Input1 = GUICtrlCreateInput("", 17, 216, 313, 29)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Button3 = GUICtrlCreateButton(i18n('browse'), 337, 216, 75, 29)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
GUICtrlSetOnEvent(-1, "BtnBrowseClick")
GUICtrlSetCursor(-1, 0)
Global $Button4 = GUICtrlCreateButton(i18n('start-scan'), 17, 256, 100, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
GUICtrlSetOnEvent(-1, "BtnScanFolderClick")
GUICtrlSetCursor(-1, 0)
Global $TabSheet4 = GUICtrlCreateTabItem(i18n('usb-scan'))
Global $Label2 = GUICtrlCreateLabel(i18n('select-usb-drive'), 17, 186, 115, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Combo1 = GUICtrlCreateCombo(i18n('no-usb'), 17, 216, 241, 25, BitOR($CBS_DROPDOWNLIST, $CBS_AUTOHSCROLL))
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
Global $Button5 = GUICtrlCreateButton(i18n('start-scan'), 267, 216, 100, 25)
GUICtrlSetFont(-1, 12, 400, 0, "Segoe UI")
GUICtrlSetOnEvent(-1, "BtnScanUsbClick")
GUICtrlSetCursor(-1, 0)
GUICtrlCreateTabItem("")
Global $Group1 = GUICtrlCreateGroup(i18n('result'), 8, 336, 305, 105)
Global $Label3 = GUICtrlCreateLabel(i18n('status'), 18, 366, 77, 25)
Global $Label4 = GUICtrlCreateLabel(i18n('waiting'), 152, 366, 111, 25)
GUICtrlSetColor(-1, 0x0000FF)
Global $Label5 = GUICtrlCreateLabel(i18n('injected-files'), 18, 401, 123, 25)
Global $Label6 = GUICtrlCreateLabel("0", 152, 401, 45, 25)
GUICtrlSetColor(-1, 0x008000)
GUICtrlCreateGroup("", -99, -99, 1, 1)
Global $Button6 = GUICtrlCreateButton(i18n('about'), 328, 344, 99, 25)
GUICtrlSetOnEvent(-1, "BtnAboutClick")
GUICtrlSetCursor(-1, 0)
Global $Button7 = GUICtrlCreateButton(i18n('contact'), 328, 380, 99, 25)
GUICtrlSetOnEvent(-1, "BtnContactClick")
GUICtrlSetCursor(-1, 0)
Global $Button8 = GUICtrlCreateButton(i18n('exit'), 328, 416, 99, 25)
GUICtrlSetOnEvent(-1, "FormMainClose")
GUICtrlSetCursor(-1, 0)

initGUI()

GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###

GUICtrlSetState($Button1, $GUI_FOCUS)

While 1
	Sleep(100)
WEnd

Func getDriveFromLabel($label)
	Return StringLeft(StringRight($label, 3), 2)
EndFunc   ;==>getDriveFromLabel

Func Button2Click()
	Local $fp = GUICtrlRead($List1)
	If _GUICtrlListBox_GetSelCount($List1) > 0 Then
		Local $data = _GUICtrlListBox_GetSelItemsText($List1)

		_GUIWorking()

		For $i = 1 To $data[0] - 1
			Local $path = getDriveFromLabel($data[$i])
			scanTarget($path)
		Next

		_GUIWorking(False)
	EndIf
EndFunc   ;==>Button2Click

Func BtnContactClick()
	ShellExecute('https://m.me/junookyo.vn')
EndFunc   ;==>BtnContactClick

Func initGUI()
	; Scan fixed drive
	Local $drive = DriveGetDrive('FIXED')
	If Not @error Then
		$driveNum = $drive[0]

		Local $data = ''

		For $i = 1 To $driveNum
			Local $me = $drive[$i]
			$data &= StringFormat('%s (%s)|', DriveGetLabel($me), StringUpper($me))
		Next

		GUICtrlSetData($List1, $data)
	EndIf

	; Scan USB drive
	$drive = DriveGetDrive('REMOVABLE')
	If Not @error And $drive[0] > 0 Then
		; Remove default value
		GUICtrlSetData($Combo1, '')

		Local $data = ''

		For $i = 1 To $drive[0]
			Local $me = $drive[$i]
			$data &= StringFormat('%s (%s)|', DriveGetLabel($me), StringUpper($me))
		Next

		GUICtrlSetData($Combo1, $data)
	EndIf
EndFunc   ;==>initGUI

Func _GUIWorking($working = True)
	Local $state = ($working) ? $GUI_DISABLE : $GUI_ENABLE
	Local $controls = [$Button1, $Button2, $Button3, $Button4, $Button5, $Button6, $Button7, $Button8, $cb_program_files, $cb_running_process, $cb_windir]

	For $control In $controls
		GUICtrlSetState($control, $state)
	Next

	If $working Then
		GUICtrlSetData($Label4, i18n('scanning'))

		; Reset counter
		GUICtrlSetData($Label6, '0')
		GUICtrlSetColor($Label6, 0x008000)
	Else
		GUICtrlSetData($Label4, i18n('completed'))
	EndIf
EndFunc   ;==>_GUIWorking

Func BtnQuickScanClick()
	_GUIWorking()
	If GUICtrlRead($cb_running_process) = 1 Then scanRunningProcess()
	If GUICtrlRead($cb_program_files) = 1 Then scanTarget(@ProgramFilesDir)
	If GUICtrlRead($cb_windir) = 1 Then scanTarget(@WindowsDir)
	_GUIWorking(False)
EndFunc   ;==>BtnQuickScanClick

Func createChecksum($path)
	Local $log = _TempFile($TEMP_DIR, '~', '.txt')
	Local $cmd = 'md5deep.exe -i 10000000 -r -j 5 -s "' & $path & '" > "' & $log & '"'
	RunWait('"' & @ComSpec & '" /c ' & $cmd, $TEMP_DIR, @SW_HIDE)
	Return $log
EndFunc   ;==>createChecksum

Func updateCounter()
	; Get current number
	Local $i = Number(GUICtrlRead($Label6))

	$i += 1 ; ++

	; Update
	GUICtrlSetData($Label6, $i)
	If $i = 1 Then GUICtrlSetColor($Label6, 0xFF0000)
EndFunc   ;==>updateCounter

Func checkHashFromLog($logFile)
	If Not FileExists($logFile) Then Return False

	Local $hashes = FileReadToArray($logFile)

	If UBound($hashes) = 0 Then
		FileDelete($logFile)
		Return False
	EndIf

	Local $aResult = [0]

	For $line In $hashes
		If StringLen($line) > 32 Then
			If isMalware(StringLeft($line, 32)) Then
				_ArrayAdd($aResult, StringMid($line, 35)) ; Path (start from char 35)
				updateCounter()
			EndIf
		EndIf
	Next

	FileDelete($logFile)
	Return checkResult($aResult)
EndFunc   ;==>checkHashFromLog

Func scanTarget($path)
	If FileExists($path) Then
		Local $log = createChecksum($path)
		checkHashFromLog($log)
		Return True
	EndIf

	Return False
EndFunc   ;==>scanTarget

Func checkResult($aResult)
	$aResult[0] = UBound($aResult) - 1

	If $aResult[0] > 0 Then
		Local $aError = [0]

		For $i = 1 To $aResult[0]
			; Try to kill process
			Local $path = $aResult[$i]
			Local $a, $b, $c, $d
			_PathSplit($path, $a, $b, $c, $d)
			Local $fileName = $c & $d

			ConsoleWrite($path & @CRLF)

			If ProcessExists($fileName) Then
				If ProcessClose($fileName) Then
					FileDelete($path)
				Else
					_ArrayAdd($aError, $path)
				EndIf
			Else
				FileDelete($path)
			EndIf
		Next

		$aError[0] = UBound($aError) - 1
		If $aError[0] > 0 Then _log($aError, True)
	EndIf
EndFunc   ;==>checkResult

Func scanRunningProcess()
	Local $files = ProcessList()
	Local $max = $files[0][0]

	If $max > 0 Then
		Local $aResult = [0]

		For $i = 1 To $max
			Local $PID = $files[$i][1]

			; Do not scan yourself
			If $PID = @AutoItPID Then ContinueLoop

			Local $path = _ProcessGetLocation($PID)
			If Not @error Then
				If isMalware(_MD5ForFile($path)) Then _ArrayAdd($aResult, $path)
			EndIf
		Next

		checkResult($aResult)
	EndIf
EndFunc   ;==>scanRunningProcess

Func _log($data, $isArray = False)
	Local $fileName = _TempFile()
	Local $fp = FileOpen($fileName, 1)

	If $isArray Then
		For $i = 1 To $data[0]
			_FileWriteLog($fp, $data[$i])
		Next
	Else
		_FileWriteLog($fp, $data)
	EndIf

	FileClose($fp)
EndFunc   ;==>_log

Func BtnBrowseClick()
	Local $fp = FileSelectFolder(i18n('browse'), @DesktopDir, 0, '', $FormMain)
	If Not @error Then GUICtrlSetData($Input1, $fp)
EndFunc   ;==>BtnBrowseClick

Func BtnScanFolderClick()
	Local $fp = GUICtrlRead($Input1)
	If $fp And FileExists($fp) Then
		_GUIWorking()
		scanTarget($fp)
		_GUIWorking(False)
	Else
		MsgBox(16 + 262144, i18n('error'), i18n('please-select-folder'), 0, $FormMain)
		GUICtrlSetState($Input1, $GUI_FOCUS)
		BtnBrowseClick()
	EndIf
EndFunc   ;==>BtnScanFolderClick

Func BtnScanUsbClick()
	Local $fp = GUICtrlRead($Combo1)
	If StringLen($fp) > 0 Then
		$fp = getDriveFromLabel($fp)
		If FileExists($fp) Then
			_GUIWorking()
			scanTarget($fp)
			_GUIWorking(False)
			Return True
		EndIf
	EndIf

	MsgBox(16 + 262144, i18n('error'), i18n('please-select-usb'), 0, $FormMain)
	GUICtrlSetState($Combo1, $GUI_FOCUS)
	Return False
EndFunc   ;==>BtnScanUsbClick

Func BannerClick()
	ShellExecute('https://junookyo.blogspot.com/')
EndFunc   ;==>BannerClick

Func TabChange()
	Local $index = _GUICtrlTab_GetCurSel($Tab1)

	Switch $index
		Case 0
			GUICtrlSetState($Button1, $GUI_FOCUS)
		Case 1
			GUICtrlSetState($Button2, $GUI_FOCUS)
			_GUICtrlListBox_SelItemRange($List1, 0, _GUICtrlListBox_GetCount($List1) - 1) ; Select all
		Case 2
			GUICtrlSetState($Input1, $GUI_FOCUS)
		Case 3
			GUICtrlSetState($Button5, $GUI_FOCUS)
	EndSwitch
EndFunc   ;==>TabChange

Func BtnAboutClick()
	MsgBox(64 + 262144, i18n('about'), i18n('about-content'), 0, $FormMain)
EndFunc   ;==>BtnAboutClick

Func FormMainClose()
	If MsgBox(32 + 4 + 256 + 262144, i18n('exit'), i18n('exit-confirm'), 0, $FormMain) = 6 Then
		GUIDelete($FormMain)
		Exit
	EndIf
EndFunc   ;==>FormMainClose

Func isMalware($hash)
	Local $pos = StringInStr($db, StringLower($hash))
	If @error Then Return False
	Return $pos > 0
EndFunc   ;==>isMalware

Func _ProcessGetLocation($iPID)
	Local $path = _WinAPI_GetProcessFileName($iPID)
	If Not @error Then Return $path

	Local $aProc = DllCall('kernel32.dll', 'hwnd', 'OpenProcess', 'int', BitOR(0x0400, 0x0010), 'int', 0, 'int', $iPID)
	If $aProc[0] = 0 Then Return SetError(1, 0, '')
	Local $vStruct = DllStructCreate('int[1024]')
	DllCall('psapi.dll', 'int', 'EnumProcessModules', 'hwnd', $aProc[0], 'ptr', DllStructGetPtr($vStruct), 'int', DllStructGetSize($vStruct), 'int_ptr', 0)
	Local $aReturn = DllCall('psapi.dll', 'int', 'GetModuleFileNameEx', 'hwnd', $aProc[0], 'int', DllStructGetData($vStruct, 1), 'str', '', 'int', 2048)
	If StringLen($aReturn[3]) = 0 Then Return SetError(2, 0, '')
	Return $aReturn[3]
EndFunc   ;==>_ProcessGetLocation

Func _MD5ForFile($sFile) ; by trancexx
	Local $hDLL = DllOpen('kernel32.dll')
	Local $a_hCall = DllCall($hDLL, "hwnd", "CreateFileW", _
			"wstr", $sFile, _
			"dword", 0x80000000, _ ; GENERIC_READ
			"dword", 3, _ ; FILE_SHARE_READ|FILE_SHARE_WRITE
			"ptr", 0, _
			"dword", 3, _ ; OPEN_EXISTING
			"dword", 0, _ ; SECURITY_ANONYMOUS
			"ptr", 0)

	If @error Or $a_hCall[0] = -1 Then
		DllClose($hDLL)
		Return SetError(1, 0, "")
	EndIf

	Local $hFile = $a_hCall[0]

	$a_hCall = DllCall($hDLL, "ptr", "CreateFileMappingW", _
			"hwnd", $hFile, _
			"dword", 0, _ ; default security descriptor
			"dword", 2, _ ; PAGE_READONLY
			"dword", 0, _
			"dword", 0, _
			"ptr", 0)

	If @error Or Not $a_hCall[0] Then
		DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFile)
		DllClose($hDLL)
		Return SetError(2, 0, "")
	EndIf

	DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFile)

	Local $hFileMappingObject = $a_hCall[0]

	$a_hCall = DllCall($hDLL, "ptr", "MapViewOfFile", _
			"hwnd", $hFileMappingObject, _
			"dword", 4, _ ; FILE_MAP_READ
			"dword", 0, _
			"dword", 0, _
			"dword", 0)

	If @error Or Not $a_hCall[0] Then
		DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFileMappingObject)
		DllClose($hDLL)
		Return SetError(3, 0, "")
	EndIf

	Local $pFile = $a_hCall[0]
	Local $iBufferSize = FileGetSize($sFile)

	Local $tMD5_CTX = DllStructCreate("dword i[2];" & _
			"dword buf[4];" & _
			"ubyte in[64];" & _
			"ubyte digest[16]")

	DllCall("advapi32.dll", "none", "MD5Init", "ptr", DllStructGetPtr($tMD5_CTX))

	If @error Then
		DllCall($hDLL, "int", "UnmapViewOfFile", "ptr", $pFile)
		DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFileMappingObject)
		DllClose($hDLL)
		Return SetError(4, 0, "")
	EndIf

	DllCall("advapi32.dll", "none", "MD5Update", _
			"ptr", DllStructGetPtr($tMD5_CTX), _
			"ptr", $pFile, _
			"dword", $iBufferSize)

	If @error Then
		DllCall($hDLL, "int", "UnmapViewOfFile", "ptr", $pFile)
		DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFileMappingObject)
		DllClose($hDLL)
		Return SetError(5, 0, "")
	EndIf

	DllCall("advapi32.dll", "none", "MD5Final", "ptr", DllStructGetPtr($tMD5_CTX))

	If @error Then
		DllCall($hDLL, "int", "UnmapViewOfFile", "ptr", $pFile)
		DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFileMappingObject)
		DllClose($hDLL)
		Return SetError(6, 0, "")
	EndIf

	DllCall($hDLL, "int", "UnmapViewOfFile", "ptr", $pFile)
	DllCall($hDLL, "int", "CloseHandle", "hwnd", $hFileMappingObject)

	Local $sMD5 = Hex(DllStructGetData($tMD5_CTX, "digest"))

	DllClose($hDLL)

	Return SetError(0, 0, $sMD5)
EndFunc   ;==>_MD5ForFile
